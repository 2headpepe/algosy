**Tags:** 
____
**Date:** 01.06.2023
**Time:** 14:37
```toc style:
bullet | number | inline (default: bullet) min_depth: number (default: 2) max_depth: number (default: 6) title: string (default: undefined) allow_inconsistent_headings: boolean (default: false) delimiter: string (default: |) varied_style: boolean (default: false)
```
____
## Стек
Стек - структура, которая работает по принципу **Last in, First out**. Более того. Доступа к любому элементу, кроме верхнего нет.
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230601150430.png]]
### Основные операции
+ `top`
+ `pop`
+ `push`

### Реализации
Реализовать эту структуру можно разными способами, и выбор этого способа зависит от задачи, которая стоит перед нами. Реализации могут быть основаны на двух основных структурах данных, а именно на [[Стеки и очереди. Очередь на двух стеках и на 6 стеках.|векторах и списках]].

#### Стек на векторе
Стек на векторе хорош в том случае, когда количество элементов, с которыми мы работаем ограничено и это ограничение нам известно. В таком случае:
+ мы легко определяем `top`, как последний(из существующих) элмент массива.
+ `push(x)`будет выглядеть как `M[++top]`
+ `pop()` будет выглядеть как `--top`

#### Стек на списке
Данная реализация подразумевает использование односвязного списка с добавлением в начало. Эффективная в том случае, если количество элементов у нас неограничено.

## Очередь
Очередь это структура данных, которая работает вот так, но без слова VODKA
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230601150152.png]]
То есть по принципу **First in, First out**.

Реализовать, опять же, можно с использованием массивов и списков, а так же на 2 и 6 стеках

### Операции
+ `push`
+ `pop`

### Реализации

#### Очередь на массиве
Этот вариант реализации использует кольцевой массив, и, конечно же, он хорош только в том случае, когда нам известно количество элемнетов. Хорошим примером использования такой реализации была очередь в задаче о программировании игры в пьяницу. 

#### Очередь на списке
Этот вариант хорош тем, что может вмещать в себя любое количество элементов. Для реализации, конечно, можно использовать двусвязный список, однако, по моему мнению, это слишком жирно. Достаточно односвязного списка и одного дополнительного указателя на конец списка. Добавление новых элементов делаем в конец списка со смещением указателя конца, а удаление делаем из начала со смещением на `next`, где `next` это уникальный для каждого нода указатель. 

#### Очередь на двух стеках
Данная реализация требует наличия двух стеков и хороша для поиска максимума и минимума. Добавление элементов за константу. Удаление, в среднем, тоже. Минимум и максимум тоже за константу находятся, потому что каждый раз записываются в каждый элмент при добавлении.

#### Очередь на шести стеках
Очередь на шести стеках - штука, которая оптимизирует единственный недостаток очереди на двух стеках, а именно удаление в худшем случае(O(n)). Для оптимизации мы делаем:
Сначала будем действовать аналогично случаю с двумя стеками.
+ Пусть у нас есть стек `L` для операций push и стек `R` для операций pop.
+ К моменту опустошения стека `R` нам нужно успеть получить стек `R′`, содержащий текущие элементы стека `L` в правильном для извлечения порядке. Перекопирование начнется, когда появится опасность того, что мы не сможем за оставшиеся `R.size` операций pop со стеком `R` перекопировать стек `L` в новый стек `R′`. Очевидно, это ситуация `L.size>R.size` (пусть такое состояние отражает специальная переменная логического типа **recopy**).
+ Во время перекопирования могут поступить операции push, а стек L в это время потеряет свою структуру, сложить элементы туда мы уже не сможем, значит нужно завести еще один стек L′, в который мы и будем складывать новые элементы. 
+ После окончания перекопирования мы поменяем ролями L,L′ и R,R′

+ Старый стек R может и не опустошится за это время, то есть мы получили два стека с выходными данными, а значит, возможен случай (например, если все поступающие операции — push), когда при следующем перекопировании у нас не будет свободного стека для копирования туда элементов L. Для преодоления этой проблемы мы принудительно будем извлекать все элементы из стека R во вспомогательный стек S, затем копировать элементы из стека L в R, а затем обратно копировать элементы из стека S в R. Легко показать, что приведенный алгоритм как раз получает на выходе в R все элементы стеков L,R в правильном порядке.
+ Если мы принудительно извлекаем элементы из стека R, появляются следующие проблемы: 
1. Что вернуть при операции pop? Для этого заведем себе стек Rc — копию стека R, из которого мы и будем извлекать требуемые элементы. 
2. Как поддерживать корректность такой копии? Поскольку этот стек нужен только для перекопирования, а во время него он занят, нужна запасная копия Rc′ для копирования всех элементов, которые мы копируем в R, а по окончании перекопирования поменяем ролями стеки Rc,Rc′, как мы делали со стеками L,L′.
3. Как учесть, что во время перекопирования часть элементов была извлечена из Rc? Для этого заведем специальную переменную toCopy, которая показывает, сколько корректных элементов находится в стеке S, и уменьшается при каждом извлечении из S или операции pop. К счастью, все некорректные элементы будут нарастать со дна стека, так что мы никогда не извлечем некорректный элемент, если toCopy>0. Если во время операции pop у нас toCopy=0, это означает, что теперь в стеке R находится весь правый кусок очереди, так что нам придется извлечь элемент из него.

+ Теперь может возникнуть проблема с непустым Rc после завершения перекопирования.
+ Покажем, что мы всегда успеем его опустошить, если будем использовать дополнительное извлечение из него при каждой операции в обычном режиме, для этого полностью проанализируем алгоритм. 
+ Пусть на начало перекопирования в стеке R содержится n элементов, тогда в стеке L находится n+1 элементов. 
+ Мы корректно можем обработать любое количество операций push, а также n операций pop. 
+ Заметим, что операция empty во время перекопирования всегда возвращает false, так как мы не можем извлекать элементы из стека L, который не пустой. Таким образом вместе с операцией, активирующей перекопирование, мы гарантированно можем корректно обработать n+1 операцию.

Посмотрим на дополнительные действия, которые нам предстоят: 
1. Переместить содержимое R в S, n действий. 
2. Переместить содержимое L в стеки R,Rc′ , n+1 действий. 
3. Переместить первые toCopy элементов из S в R,Rc′, остальные выкинуть, n действий. 
4. Поменять ролями стеки Rc,Rc′, L,L′, 2 действия. • Таким образом, получили 3
+ n+3 дополнительных действия за n+1 операций, или 3=O(1) дополнительных действий на операцию в режиме перекопирования, что и требовалось.

+ Рассмотрим, как изменились наши стеки за весь период перекопирования. 
+ Договоримся, что операция empty не меняет очередь, то есть никакие дополнительные действия не совершаются. Пусть за n следующих за активацией меняющих операций (push,pop) поступило x операций pop, n−x операций push. Очевидно, что после перекопирования в новых стеках окажется: n−x элементов в L, 2⋅n+1−x=(n−x)+(n+1) элементов в R, то есть до следующего перекопирования еще n+2 операции. С другой стороны, стек Rc содержал всего n элементов, так что мы можем очистить его, просто удаляя по одному элементу при каждой операции в обычном режиме. 
+ Итак, очередь Q будет состоять из шести стеков L,L′,R,Rc,Rc′,S, а также двух внутренних переменных recopy, toCopy, которые нужны для корректности перекопирования + дополнительная переменная copied, показывающая, перемещали ли мы элементы из стека L в стек R, чтобы не начать перемещать эти элементы в стек S.

+ Инвариант очереди (обычный режим): 
1. Стек L содержит левую половину очереди, порядок при извлечении обратный. 
2. Стек R содержит правую половину очереди, порядок при извлечении прямой. 
3. L.size⩽R.size 
4. R.size=0 ≡ Q.size=0 
5. Rc — копия R 
6. Rc′.size
7. L′.size=0,S.size=0 
+ Тогда к следующему перекопированию (L.size=R.size+1) мы гарантированно будем иметь пустые стеки L′,S,Rc′, которые нам понадобятся.
+ Инвариант очереди (режим перекопирования): 
1. Rc.size = toCopy 
2. Если L.size = 0, то: 
   +  При toCopy>0 первые toCopy элементов S — корректны, то есть действительно содержатся в очереди. 
   + При toCopy⩽0 стек R содержит весь правый кусок очереди в правильном порядке.

+ Очередь будет работать в двух режимах: 
1. Обычный режим, кладем в L, извлекаем из R и из Rc,Rc′ для поддержания порядка, операция empty=(R.size=0). 
2. Режим перекопирования, кладем в L′, извлекаем из Rc, возможно из R, empty=false, совершаем дополнительные действия. 
+ Также после операции в обычном режиме следует проверка на активацию перекопирования (recopy=(L.size>R.size)), если это так, toCopy=R.size,recopy=true,copied=false, совершается первый набор дополнительных действий. 
+ После операции в режиме перекопирования следует проверка на завершение перекопирования `(recopy=(S.size==0))`, а при завершении меняются ролями стеки Rc,Rc′, L,L′.

У Погожева записи лекций есть. Там всё понятно. Просто включил лекцию на удобной скорости, закрыл глаза, представил всё, что он говорит и ВУАЛЯ, ты всё понял. 

## Список ссылок
____
**Zero-links:**
+ [[00_Алгоритмы и структуры данных]]

**Links:**
+ [[Линейные структуры данных. вектор, список.]]