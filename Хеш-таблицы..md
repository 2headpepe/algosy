**Tags:** 
____
**Date:** 02.06.2023
**Time:** 16:47
```toc style:
bullet | number | inline (default: bullet) min_depth: number (default: 2) max_depth: number (default: 6) title: string (default: undefined) allow_inconsistent_headings: boolean (default: false) delimiter: string (default: |) varied_style: boolean (default: false)
```
____
## Хеш-таблицы
Усовершенствованный массив. С возможностью:
+ Искать
+ Удалять
+ Добавлять
И всё это за константу.
Однако, они хороши для этого и только. По-факту обычный словарь. Кстати говоря, в худшем случае, требуется всё же O(n) времени. 
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230602170830.png|600]]
+ Пространство реальных ключей K может быть меньше пространства обычных ключей и это пустая трата памяти.
+ функция, которая сопоставляет элементу из U(наш массив) элемент из K называется хеш-функцией и обозначается, как h.
+ Когда функция сопоставляет одной ячейке в массиве несколько элементов из K, то это называется **коллизией** и это плохо.

### Метод цепочек
Метод заключается в том, что в каждой ячейке массива у нас не просто элемент, а целый список, что означает, что при возникновении коллизий, мы просто записываем элемент в список и всё хорошо.

#### Функций
+ Функции, которые мы будем использовать, в идеале, должны делать распределение по массиву равномерным. 
+ Считается важным выбрать функцию, которая никак не зависит от вводимых данных, чтобы не подобрать данные и не затормозить функцию

##### Метод деления
Ищем остаток от деления на длину массива. Хорошо работает в том случае, когда m - простое число.
$h(k)=k\space mod \space m$

##### Метод умножения
$h(k) = m(kA\space mod \space 1)$
+ A - константа, которая выбирается произвольно, однако есть хорошее предложение от Кнута $A = \frac{\sqrt 5 - 1}{2}$
+ Часть в скобках берет дробную часть от $kA$
+ m - размер массива, но лучше его делать степенью двойки

#### Универсальное хеширование
$h(k) = ((ak + b) mod \space p)mod \space m$
+ Все ключи должны находиться в диапазоне от 0 до p-1
+ $a \in [1, p-1]$
+ $b \in [0,p-1]$
+ m - размер массива. Простое число
+ p - размер диапазона. Простое число > m

### Открытая адресация
Тут мы делаем немного иначе. Если возникла коллизия, то мы рассматриваем другую ячейку таблицы. И никаких листов. 

#### Функции
Функция, в данном случае будет иметь два аргумента, где второй аргумент будет показывать номер испытания(количество попыток впихнуть элемент в таблицу). Соответственно, наша задача в том, чтобы посмотреть все возможные ячейки.

##### Метод линейного исследования
$h(k,i)=(h'(k) + i)mod\space m$
+ k - ключ
+ i - номер ячейки от 0 до m-1
+ m - количество ячеек. Предполагаю, что есть смысл в том, чтобы число было простым
+ h'(k) -  одна из функций-методов предложенных выше

##### Метод квадратичного исследования
$h(k,i) = (h'(k) + ic_1 + i^2 c_2) mod\space m$
+ h’ — вспомогательная хеш-функция
+ c1 и c2 ≠ 0 — вспомогательные константы
+ i принимает значения от 0 до m−1 включительно
+ m - количество ячеек

##### Метод двойного хеширования
$h(k,i) = (h_1(k) + ih_2(k))mod\space m$
+ h1 и h2 -  функции из списка выше
+ i принимает значения от 0 до m−1 включительно
+ m - количество ячеек
+ h1 посчитали, на h2 сместились, если ячейка занята. Повторяем, пока не нашли пустую ячейку

### Метод идеального хеширования
Два универсальных хеширования. Одно по основной таблице, второе по каждой ячейке. Таблица таблиц получается.
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230602213648.png|600]]

## Список ссылок
____
**Zero-links:**
+ [[00_Алгоритмы и структуры данных]]

**Links:**
+ [[Линейные структуры данных. вектор, список.]]