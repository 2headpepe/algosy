**Tags:** 
____
**Date:** 04.06.2023
**Time:** 17:23
```toc style:
bullet | number | inline (default: bullet) min_depth: number (default: 2) max_depth: number (default: 6) title: string (default: undefined) allow_inconsistent_headings: boolean (default: false) delimiter: string (default: |) varied_style: boolean (default: false)
```
____
## Простой алгоритм
Да. Это то, что приходит в голову, в первую очередь. Да, это 24 задача из ЕГЭ.
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230604172631.png|600]]
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230604172647.png|600]]
Очевидно, это всё херня. Таким пользуются только лохи.
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230604172847.png|600]]
Просто посмотри на эту строку и вспомни алгоритм...

## Алгоритм Рабина-Карпа
Алгоритм работает на хеш-функциях. Хешируем подстроку длины нашей искомой строки с помощью полиномиальной хеш-функции, сравниваем хеш(это просто). Идем дальше. Расхешируем первый знак, хешируем следующий символ. Таким образом у нас есть массив хешированных подстрок исходной строки и хеш искомой строки. Если хеш совпал, то на этой подстроке применяем простой алгоритм(лоховской из предыдущего пункта)
$O(n + m + \frac{n\cdot m}{P})$

## Алгоритм Кнута—Морриса—Пратта
1. Находим префикс(которые максимальный и является суффиксом)
2. В момент, когда у нас часть слова не сошлась, мы переходим не на 1 символ вперед, а на ближайший суффикс

Для реализации шага два мы используем массив, который указывает на количество символов в префиксе в искомой строке на данной длине. И получаем вот такой переход:
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230604183649.png|600]]

## Алгоритм Бойера—Мура
1. Смотрим последний символ, если совпал, то смотрим предыдущий
2. Повторяем до момента, пока не найдем различие
3. Если нашли различие, то передвигаем слово на букву, которая отличается.
   ![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230604192451.png|300]]
4. Если нет соответствующих букв, то сдвигаем слово целиком
   ![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230604192614.png|300]]

### Эвристика "плохого символа"
Для ее реализации мы фиксируем самую правую позицию символа в искомой строке и сдвигаем на нее, в случае, если у нас различие в строке.

### Эвристика "хорошего" суффикса
Тут мы делаем сдвиг не просто на какой-то символ с самым правым включением, а на наибольший(справа налево) совпадающий суффикс.
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230604195351.png|600]]

![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230604195445.png|600]]
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230604195642.png|600]]


### Совместное использование эвристик
Мы объединяем первый и второй алгоритм и делаем сдвиг только на максимальную из двух предложенных нашими эвристиками величину. Победа. Алгоритм Top G запроган.

## Список ссылок
____
**Zero-links:**
+ 

**Links:**
+ 