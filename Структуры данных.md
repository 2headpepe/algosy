**Tags:** 
____
**Date:** 21.02.2023
**Time:** 14:11
```toc style:
bullet | number | inline (default: bullet) min_depth: number (default: 2) max_depth: number (default: 6) title: string (default: undefined) allow_inconsistent_headings: boolean (default: false) delimiter: string (default: |) varied_style: boolean (default: false)
```
____
## Односвязный список
>Всегда косяк с дополнительной памятью, которая требуется для хранения указателей.
+ Узел
	+ Содержит одно или несколько полей для хранения данных
	+ содержит поле указатель на следующий узел
+ Требуется указатель на начало структуры
+ Операции: вставка, удаление, поиск
+ Преимущества над массивами
	+ вставка и удаление элементов за $\theta(1)$
	+ при работе с большими записями, перемещение указателей легче, чем перемещение самих записей. Соответственно, мы выигрываем по времени.
+ Недостатки:
	+ дополнительная память для хранения указателей $\theta(n)$
	+ нет эффективного произвольного доступа к элементам
	+ нет такой локальности, как у массивов
```C++
struct Node{
T data;
Node* next
}
//--add first--
Node* list;
list = nullptr
//--add new--
list - new Node;
list -> next - nullptr;
//--add new--
Node*tmp=new Node;
tmp -> next = list;
list = tmp;
//--erase--
tmp = list;
list = list.next;
delete tmp;
```
+ При этом, если мы хотим удалить элемент из середины, то есть смысл просить предыдущий (от удаляемого) элемент.
+ Если мы хотим удалить первый элемент, то есть смысл создать нулевой первый элемент, на который мы будем ссылаться для удаления первого.
### Двусвязный список
Храним указатели на первый и на последний элемент(чтобы добавлять в начало и в конец)

## Стек
>Стек - конструкция, работабщая по принципу last in, first out
### Операции
+ `push(x,s)` - добавить элемент $x$ на верх(в конец стека $s$)
+ `pop(s)` -  извлечь верхний(последний) элемент из стека
+ `pop(s)` - посмотреть элемент на вершине стека
### Реализация
#### Стек на массиве
+ С помощью массива и его возможности резервирования памяти. 
  То есть у нас есть какой-то указатель на массив и говорим, что `arr[++top] = x` 
	+ `top()`
	      `data[top]`
	+ `pop()`
		`--top` 
	+ `push`
		`data[++top]=x`

Есои будет известно, что стек будет не более чем на 100 элементов. То я могу выделить массив сразу на 100 элементов и буду использовать этот массив, как стек на 100 элементов.
#### Стек на списке
Тут мы используем односвязный список с добавлением в начало. Тогда для стека будет лучше использовать как односвязный список.

## Очереди 
Удобная структура данных для решения задач в теории графов.
Работает в First in, first out
### Операции
+ `push(x,q)` или `enqueue(x,q)` -  вставить элемент x в конец очереди q
+ `pop(q)` или `dequeue(q)` - извлечь элемент в начале очереди q
### Реализация
#### Через массивы
Реализовать можно удобно с помощью удобно на кольцевых массивах. Указатели   `last` и `first` можно высчитывать как остаток от деления на количество элементов массива
ДАННЫЙ ВАРИАНТ ВЫГОДНЕЕ ИСПОЛЬЗОВАТЬ ДЛЯ ЗАДАЧИ №2
#### Через списки
Работаем через односвязный список с добавлением в конец и удалением с начала. 

## Реализация очереди с помощью двух стеков
>Реализация стека на блинах

Два стека `leftStack` и `rightStack`
`leftStack` используем для операции `puch`
`rightStack` используем для операции `pop`
Если при попытке извлечения элемента из `rightStack` он оказался пустым, перенесем все элементы из `leftStack` в него(при этом элементы в `rightStack` получается уже в обратном порядке, что и нужно для извлечения элементов, а `leftStack` станет пустым)

Важно понимать, что если мы хотим фиксировать минимальный элемент в очереди, мы должны запоминать минимальный элемент для каждого элемента 


### Реализация очереди на 6 стеках
Реализована в презентации

## Словари
+ Доступ к данным по содержимому
### Операции
+ `search(D,k)` - возвращает указатель на элемент словаря `D` с ключом `k`
+ `insert(D,k)` - добавляет эоемент `x` в словарь `D`
+ `erase(D,x)`- удаляет из словаря `D` элемент `x`
### Дополнительные операции
+ `max(D)`, `min(D)` - указатель на элемент с наибольшим или наименьшим ключом
+ `predecessor(D,k)`,`successor(D,k)` - элемент предшествующий элементу с ключом `k` или стоящий сразу после него соответственно.
### Реализация
+ **Массивы**: упорядоченный, неупорядоченный
+ **Списки**: односвязный, двусвязный, упорядоченный, неупорядоченный
____
**Zero-links:**
+ 

**Links:**
+ 