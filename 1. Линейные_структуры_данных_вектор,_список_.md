**Tags:** 
____
**Date:** 01.06.2023
**Time:** 13:15
```toc style:
bullet | number | inline (default: bullet) min_depth: number (default: 2) max_depth: number (default: 6) title: string (default: undefined) allow_inconsistent_headings: boolean (default: false) delimiter: string (default: |) varied_style: boolean (default: false)
```
____
## Линейные структуры данных
Вообще говоря, существует несколько видов структур данных. Каждая структура имеет свои плюсы и минусы и сравнивать их друг с другом в абстракции не имеет никакого смысла, потому что каждая из этих структур хорошо подходит для одних случаев и не подходит для других.

### Список структур данных
+ Массивы
+ Списки
+ Хэш-таблицы
+ Деревья
+ Кучи

#### Непрерывные/Смежные структуры данных
Тут всё последовательно представляется в памяти
+ Массивы
+ Хэш-аблицы
+ Кучи
+ Матрицы

#### Связные структуры данных
Отличие в том, что тут храним указатели отдельно
+ Списки
+ Дереврья
+ Кучи
+ Хэш-таблицы

### Абстрактные типы данных
Абстрактные типы данных рализуются с помощью структур данных из списка выше.
+ Стек
+ Очередь
+ Словарь
+ Очереди с приоритетами
+ Множества
+ Графы

## Какие структуры данных являются линейными?
Линейными структурами данных являются те, которые представляют из себя последовательность элементов, то есть у каждого элемента есть доступ к последующему и к предыдущему элементу. При этом следующих и предыдущих элементов может быть не более 1. В таком случае, мы можем выделить такие типы данных, как:

### Примеры
+ Массивы (статический, динамический)
+ Связный список
+ Хэш-таблица
Соответственно, из них можно придумать абстрактные линейные типы данных:
+ Стек
+ Очередь
+ Множества

## Вектор
### Массив
+ Основная структура данных смежного типа. 
+ Записи данных имеют постоянных размер, что позволяет находить любой элемент по его индексу (или адресу). 

#### Достоинства
+ Постоянное время доступа при условии наличия индекса (сложность O(1)) 
+ Эффективное использование памяти (дополнительная память O(1)) 
+ локальность памяти 

И, к сожалению, переход от массива к вектору осуществлеятся вместе с появлением его недостатка

#### Недостатки
+ Изменение размера в процессе исполнения программы (сложность O(n))

Однако, данный недостаток можно избежать путем увеличения выделенной памяти в несколько раз. Для примера буду использовать удвоение.
+ В таком случае мы получим, что необходимость удваивать память возникнет $log_2 n$ раз, что, в целом, неплохо, потому что не надо удваивать слишком часто, а памяти мы не так много занимаем(только в 2 раза больше). Да, конечно, могут возникнуть corner cases, что, в общем и цело не так приятно, но это погрешность.
+ Количество перезаписей, в данном случае, будет эквивалентно $n \sum \limits_{i=1} ^{lg n} \frac{i}{2^i}\leq \sum \limits_{i = 1} ^{\infty} \frac{i}{2^i}= 2n$
+ А каждый элемент, в среднем, перезаписывается 2 раза(очень в среднем)


## Список
+ Указатель – адрес ячейки памяти. 
+ Узел - содержит одно или несколько полей для хранения данных 
+ Содержит поле указатель на следующий узел 
+ Требуется указатель на начало структуры 
+ Операции: вставка, удаление, поиск

### Преимущества над массивами 
+ Вставка и удаление элементов за Θ (1) 
+ При работе с большими записями, перемещение указателей легче, чем перемещение самих записей 

### Недостатки 
+ Дополнительная память для хранения указателей Θ(n) 
+ Нет эффективного произвольного доступа к элементам 
+ Нет такой локальности как у массивов


## Список ссылок
____
**Zero-links:**
+ [[00_Алгоритмы и структуры данных]]

**Links:**
+ 