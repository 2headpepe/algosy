**Tags:** 
____
**Date:** 03.06.2023
**Time:** 13:25
```toc style:
bullet | number | inline (default: bullet) min_depth: number (default: 2) max_depth: number (default: 6) title: string (default: undefined) allow_inconsistent_headings: boolean (default: false) delimiter: string (default: |) varied_style: boolean (default: false)
```
____
## В чем задача?
Задача: оптимально реализовать операции
+ `Find(x)`. Операция находит представителя подмножества, которому принадлежит`x`
+ `Union(x,y)`. Объединяем множества, выбирая единого представителя из `x`, `y`
+ `MakeSet(x)`. Делаем из `x` подмножество, назначем его представителем


## Простейшая реализация
Реализация заключается в том, что в массиве у нас все элементы = -1, а элементы множества - индексы массива.

![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230603140319.png|600]]
Тогда:
### Операция Find
Будет выглядеть так
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230603140604.png|600]]
То есть, у нас в каждой ячейке будет номер ячейки представителя множества.

### Операция Union
Будет реализована, как переписывание у всех элементов этого множества представителя в ячейке, что(очевидно) долго

## Вторая реализация
Тут мы делаем таким образом:
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230603140922.png|600]]
То есть у нас представитель - элемент, у которого нет исходящих связей.
Как можно догадаться, нахождение этого представителя будет рекурсивная функция(что, в теории может быть медленно. Прикиньте просто лоза, как в [[4. Сбалансированные ДДП. АВЛ-дерево.#Балансировка|ДДП]]. Там же n операций прям потребуется, в худшем случае), а объединение будет гораздо быстрее. Нужно просто у одного из представителей сделать ссылку на другого.


## Эвристика объединения по рангу
Тут сохраняется идея второго подхода, но у представителя множества хранится количество элементов этого множества. Тогда при объединении множество с меньшим рангом объединится с множеством, у которого ранг больше и большее останется представителем. Большее становится представителем, потому что путь становится на 1 больше и для большего подмножества это выигрыш на этот один шаг.

## Эвристика сжатия путей
Если вершина по какой-то причине является более популярной, то частое обращение к ней и потенциальный долгий путь от нее до представителя - отстой, поэтому при обращении к какой-то конкретной вершине, мы связываем ее непосредственно с преставителем. Так же мы поступаем со всеми вершинами, которые встретились по пути до представителя.
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230603143621.png|600]]
## Список ссылок
____
**Zero-links:**
+ [[00_Алгоритмы и структуры данных]]

**Links:**
+ [[Хеш-таблицы.]]
+ [[Линейные структуры данных. вектор, список.]]