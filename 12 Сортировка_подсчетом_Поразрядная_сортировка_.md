**Tags:** 
____
**Date:** 03.06.2023
**Time:** 20:56
```toc style:
bullet | number | inline (default: bullet) min_depth: number (default: 2) max_depth: number (default: 6) title: string (default: undefined) allow_inconsistent_headings: boolean (default: false) delimiter: string (default: |) varied_style: boolean (default: false)
```
____
## Сортировка подсчетом. Counting sort
1. Если сортируем не числа, то кодируем элементы числами в диапазоне от 0 до k-1
2. Создаем массив P на k элементов
3. Проходим по массиву закодированных чисел и выписываем частоту появлений `i` числа в `P[i]` ячейку. 
4. Составляем префиксные суммы для этого массива
5. Сдвигаем его вправо на 1 элемент (из-за того, что начало с 0)
   + Получаем, что первый элемент этого массива = 0, а остальные равны i - 1 элементу до сдвига
   + Есть альтернатива без сдвига. Просто сначала отнимаем значение и получаем позицию
6. Проходим по исходному массиву с закодированными числами и с учетом прочитанного числа и значения под его индексом в массиве `P[i]`, мы попадаем в нужную ячейку выходного массива, куда и записываем число
7. Увеличиваем значение под индексом этого элемента в массиве `P`/или нет. Зависит от тактики, которую применять
8. Повторяем действия 6 и 7 для всех элементов массива при прохождении

## Поразрядная сортировка
### LSD
1. Сортируем по последней цифре
2. Сортируем массив из шага 1 по предпоследней
... и тд.
3. По первой
Для сортировки чисел используем Counting sort, которая описана выше. Очень хорошо метчится

### MSD
По факту, всё то же самое, но в обратную сторону.
1. Сортируем по первому числу
2. Ограничиваем перемещение чисел
Крч лень писать. Вот картинка.
![[Картинки/╨Ъ╨░╤А╤В╨╕╨╜╨║╨╕/Pasted image 20230603214117.png|600]]

## Список ссылок
____
**Zero-links:**
+ [[00_Алгоритмы и структуры данных]]

**Links:**
+ 